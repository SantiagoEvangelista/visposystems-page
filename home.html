<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>RF Step-Based Scroll Animation</title>

  <!-- Preload key images (update paths) -->
  <link rel="preload" as="image" href="/img/product.webp">
  <link rel="preload" as="image" href="/img/drone.webp">

  <!-- GSAP + ScrollTrigger (UMD) -->
  <script defer src="https://unpkg.com/gsap@3/dist/gsap.min.js"></script>
  <script defer src="https://unpkg.com/gsap@3/dist/ScrollTrigger.min.js"></script>

  <style>
    :root{
      --bg:#0b0e13;
      --fg:#e7eef6;
      --wave:#8fd4ff;
      --accent:#9be4ff;
    }
    html,body{margin:0;padding:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif}

    /* Landing (placeholder) */
    .landing{min-height:120vh;display:grid;place-items:center;padding:4rem 1.5rem}
    .landing h1{font-size:clamp(2rem,6vw,4rem);text-align:center;line-height:1.1;max-width:22ch}

    /* RF Section (pinned stage + invisible step controllers) */
    .rf-section{position:relative}
    .rf-stage{position:sticky;top:0;height:100vh;overflow:hidden}
    .rf-frame{position:relative;width:100%;height:100%}

    /* Right-side content grid: pushes content to the right */
    .rf-right{
      position:absolute;inset:0;
      display:grid;grid-template-columns:1fr minmax(320px,560px);
      align-items:center;column-gap:clamp(16px,4vw,56px);
      padding:clamp(16px,3vw,40px);
    }
    .rf-spacer{ /* left column blank */ }

    /* Headlines (we crossfade between multiple) */
    .rf-copy{justify-self:end;text-align:right;max-width:48ch;position:relative}
    .rf-eyebrow{opacity:.7;font-size:.9rem;letter-spacing:.14em;text-transform:uppercase}
    .rf-headline{margin:.35rem 0 0;font-size:clamp(1.25rem,2.4vw,1.6rem);line-height:1.35;color:var(--accent)}
    .rf-desc{opacity:.85;margin-top:.75rem;font-size:.98rem}
    .rf-headline.abs{position:absolute;top:0;right:0}

    /* Product image (right) */
    .rf-product{justify-self:end;align-self:center;position:relative}
    .rf-product img{
      width:min(42vmin,520px);height:auto;display:block;
      filter:drop-shadow(0 14px 40px rgba(0,0,0,.5));
      transform-origin:50% 50%;opacity:0;transform:translateY(10px) scale(.98)
    }

    /* Drone (appears on later step) */
    .rf-drone{
      position:absolute;right:clamp(16px,6vw,80px);top:clamp(16px,10vh,160px);
      width:min(30vmin,420px);pointer-events:none;opacity:0;
      transform:translate3d(0,0,0) scale(.6);
      filter:drop-shadow(0 10px 30px rgba(0,0,0,.55))
    }

    /* Full-viewport SVG overlay for waves */
    .rf-waves{position:absolute;inset:0;width:100%;height:100%}

    /* Invisible step controllers: one viewport each */
    .rf-steps{position:relative}
    .rf-step{height:100vh}

    .hint{position:fixed;bottom:14px;left:50%;transform:translateX(-50%);opacity:.55;font-size:13px;letter-spacing:.2px;pointer-events:none}

    @media (prefers-reduced-motion: reduce){
      .rf-stage{position:relative}
    }
  </style>
</head>
<body>
  <!-- Landing (your own hero goes here) -->
  <section class="landing">
    <h1>Landing content here</h1>
  </section>

  <!-- RF Section: Pinned stage + step controllers -->
  <section class="rf-section" id="rf-section">
    <div class="rf-stage" aria-label="Step-based product features with looping animations">
      <div class="rf-frame">

        <!-- SVG overlay for RF waves -->
        <svg class="rf-waves" viewBox="0 0 100 100" preserveAspectRatio="none" aria-hidden="true">
          <defs>
            <filter id="rf-glow" x="-50%" y="-50%" width="200%" height="200%">
              <feGaussianBlur in="SourceGraphic" stdDeviation="1.2" result="b"/>
              <feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge>
            </filter>
          </defs>
          <g id="rf-waves-group" stroke="var(--wave)" stroke-width="0.35" fill="none" filter="url(#rf-glow)"></g>
        </svg>

        <!-- Right-side layout (text + product) -->
        <div class="rf-right">
          <div class="rf-spacer" aria-hidden="true"></div>

          <div class="rf-copy">
            <div class="rf-eyebrow">Signal Intelligence</div>

            <!-- Headline 1 (default) -->
            <h2 class="rf-headline" id="rf-headline">
              real time processing and analysis<br/>
              for instant threads detection
            </h2>

            <!-- Headline 2 (crossfades on step 1) -->
            <h2 class="rf-headline abs" id="rf-headline-2" style="opacity:0; transform: translateY(6px);">
              adaptive RF analytics for complex environments
            </h2>

            <p class="rf-desc">Scroll to step through key features. Each step loops while you read.</p>
          </div>

          <div class="rf-product">
            <img id="rf-product-img" src="/img/product.webp" alt="Product" />
          </div>
        </div>

        <!-- Drone (appears on later step) -->
        <img class="rf-drone" id="rf-drone-img" src="/img/drone.webp" alt="Drone"/>
      </div>
    </div>

    <!-- Invisible step controllers (one per feature/slide) -->
    <div class="rf-steps">
      <div class="rf-step" data-step="0" data-label="featureA"></div>
      <div class="rf-step" data-step="1" data-label="featureB"></div>
      <div class="rf-step" data-step="2" data-label="featureC"></div>
    </div>
  </section>

  <div class="hint">Scroll: snap through features • loops play on each step</div>

  <script>
  // ===== Step-based controller with GSAP + ScrollTrigger =====
  (() => {
    if (typeof gsap === 'undefined') return;
    gsap.registerPlugin(ScrollTrigger);

    const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    const section  = document.querySelector('#rf-section');
    const stage    = section?.querySelector('.rf-stage');
    const stepsEls = gsap.utils.toArray('.rf-step');

    // Stage elements
    const product  = document.getElementById('rf-product-img');
    const drone    = document.getElementById('rf-drone-img');
    const wavesG   = document.getElementById('rf-waves-group');
    const headline = document.getElementById('rf-headline');
    const headline2= document.getElementById('rf-headline-2');

    if (!section || !stage || !stepsEls.length || !wavesG) return;

    // ---- Wave helpers ----
    const emitFrom = { x: 82, y: 60 }; // tweak to product's RF origin (viewBox %)
    function makeRings(count = 3, spacing = 8, startR = 12) {
      const rings = [];
      for (let i = 0; i < count; i++) {
        const c = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        c.setAttribute('cx', emitFrom.x);
        c.setAttribute('cy', emitFrom.y);
        c.setAttribute('r', 0.01);
        c.style.opacity = 0;
        wavesG.appendChild(c);
        rings.push(c);
      }
      return rings;
    }

    function wavePulseLoop({ count = 3, spacing = 8, startR = 12, expandTo = 140, gap = 0.12 }) {
      const rings = makeRings(count, spacing, startR);
      const tl = gsap.timeline({ repeat: -1, defaults: { ease: 'power2.out' } });
      rings.forEach((el, i) => {
        const r1 = startR + i * spacing;
        tl.fromTo(el, { r: 0.2, opacity: 0 }, { r: r1, opacity: 0.85 - i * 0.15, duration: 0.8 }, i * gap)
          .to(el, { r: expandTo, opacity: 0, duration: 0.9 }, i * gap + 0.45);
      });
      return { tl, rings };
    }

    // ---- Step definitions ----
    // Each step factory returns: { enterTL, loopTL, exitTLFactory, cleanup }
    const StepDefs = [
      // Step 0 — Feature A: intro + waves (light)
      () => {
        const tIn = gsap.timeline();
        tIn.fromTo(product, { opacity:0, y:10, scale:.98 }, { opacity:1, y:0, scale:1, duration:.6 }, 0)
           .to(headline, { opacity:1, y:0, duration:.4 }, 0);

        const { tl: loopTL, rings } = wavePulseLoop({ count:3, spacing:8, startR:12, expandTo:140, gap:0.14 });

        const exit = () => gsap.timeline()
          .to(headline, { opacity:0, y:-6, duration:.35 }, 0);

        const cleanup = () => rings.forEach(r => r.remove());
        return { enterTL: tIn, loopTL, exitTLFactory: exit, cleanup };
      },

      // Step 1 — Feature B: swap headline, denser waves
      () => {
        const tIn = gsap.timeline();
        if (headline && headline2) {
          tIn.to(headline,  { opacity:0, y:-6, duration:.3 }, 0)
             .to(headline2, { opacity:1, y:0,  duration:.4 }, 0.05);
        }

        const { tl: loopTL, rings } = wavePulseLoop({ count:5, spacing:6, startR:10, expandTo:150, gap:0.10 });

        const exit = () => gsap.timeline()
          .to(headline2 || headline, { opacity:0, y:-6, duration:.3 }, 0);

        const cleanup = () => rings.forEach(r => r.remove());
        return { enterTL: tIn, loopTL, exitTLFactory: exit, cleanup };
      },

      // Step 2 — Feature C: reveal drone, hover loop
      () => {
        const tIn = gsap.timeline();
        tIn.to(drone, { opacity:1, scale:1, filter:'blur(0px)', duration:.7, ease:'power3.out' }, 0);

        const loopTL = gsap.timeline({ repeat:-1 })
          .to(drone, { y:-6, duration:1.4, ease:'sine.inOut' })
          .to(drone, { y: 0, duration:1.4, ease:'sine.inOut' });

        const exit = () => gsap.timeline()
          .to(drone, { opacity:0, duration:.35 }, 0);

        const cleanup = () => {};
        return { enterTL: tIn, loopTL, exitTLFactory: exit, cleanup };
      }
    ];

    // ---- Controller wiring ----
    const StepState = { current: -1, instances: [] };

    // Build instances now (pause loops by default)
    StepDefs.forEach((factory, idx) => {
      const inst = factory();
      inst.loopTL.pause(0);
      inst.enterTL.pause(0).progress(0);
      StepState.instances[idx] = inst;
    });

    // Pin the stage for the whole steps height
    if (!prefersReduced) {
      ScrollTrigger.create({
        trigger: section,
        start: 'top top',
        end: () => '+=' + (stepsEls.length * window.innerHeight),
        pin: stage,
        anticipatePin: 1
      });
    }

    // Snapping across the steps
    if (!prefersReduced) {
      ScrollTrigger.create({
        trigger: '.rf-steps',
        start: 'top top',
        end: () => '+=' + (stepsEls.length * window.innerHeight),
        scrub: 0.1,
        snap: {
          snapTo: (raw) => {
            const idx = Math.round(raw * (stepsEls.length - 1));
            return idx / (stepsEls.length - 1);
          },
          duration: 0.4,
          ease: 'power1.inOut'
        }
      });
    }

    // Per-step activation
    stepsEls.forEach((el, idx) => {
      ScrollTrigger.create({
        trigger: el,
        start: 'top center',
        end: 'bottom center',
        onEnter: () => activateStep(idx),
        onEnterBack: () => activateStep(idx)
      });
    });

    function activateStep(idx){
      if (StepState.current === idx) return;

      // exit previous
      const prev = StepState.current;
      if (prev >= 0) {
        const prevInst = StepState.instances[prev];
        prevInst.loopTL.pause();
        const exitTL = prevInst.exitTLFactory?.();
        if (exitTL) exitTL.eventCallback('onComplete', prevInst.cleanup || null);
        else prevInst.cleanup && prevInst.cleanup();
      }

      // enter new
      const inst = StepState.instances[idx];
      inst.enterTL.restart(true);
      inst.loopTL.restart(true);

      StepState.current = idx;
    }

    // Reduced motion fallback: show first step’s static state
    if (prefersReduced) {
      const first = StepState.instances[0];
      if (first) first.enterTL.progress(1);
      StepState.instances.forEach(inst => inst.loopTL.pause(0));
      gsap.set([drone], { opacity:1, scale:1, filter:'none' }); // ensure visible if needed
    }
  })();
  </script>
</body>
</html>
